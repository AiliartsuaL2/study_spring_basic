# study_spring_basic
인프런 김영한 '스프링 핵심 원리 기본편' 라이브 코딩 및 필기

스프링 이야기
- 스프링 이전엔 EJB(Enterprise Java Beans)가 있었음,, 근데 한대당 수천만원 급으로 비쌌음
    - ORM도 지원하고, 분산기술등으로 이론적으론 좋았음
        - 실질적으론 어렵고 복잡하고 느림
        - 여기서 POJO(PlainOldJavaObject)가 나옴
    - Hibernate의 등장,, >> Java에서 공식적으로 JPA(실용성 + 안정성) 채택
- 표준 인터페이스 : JPA 
    - 구현체들 : Hibernate(80%이상 선점), EclipseLink 등등,, 
- 스프링의 탄생
    - 로드존슨이 예제 코드 작성함 
        - EJB의 문제점 지적,,
        - 여기서 스프링 핵심 개념 기반의 내용이 나옴
    - 유겐 휠러 ~~ 오픈소스 프로젝트 제안,, J2EE(EJB)라는 겨울을 넘은 스프링이라는 이름 나옴

스프링이란?
- 필수 
    - 스프링 프레임워크 
        - 핵심 기술 : 스프링 DI 컨테이너, AOP , 이벤트., 등등
    - 스프링 부트
        - 스프링을 편리하게 사용 할 수 있도록 지원(dependency 설정 등) 최근에는 기본적으로 사용
        - 톰캣같은 웹 서버를 내장해서 단독으로 실행 할 수 있는 스프링 애플리케이션 쉽게 생성
        - 손쉬운 빌드 구성을 위한 starter 종속성 제공
        - 스프링과 3rd parth 라이브러리 자동 구성 (버전을 자동 맞춤)
        - 관례에 의한 간결한 설정 _ 필요한 경우 커스터마이징 가능
- 선택
    - 스프링 데이터
        - DB를 편하게 연동해주는
        - 제일 많이 쓰는건 스프링 데이터 JPA
    - 스프링 세션 : 세션 응용 기술
    - 스프링 시큐리티 : 보안 관련 기술
    - 스피링 Rest Docs : 문서 지원 기술
    - 스프링 배치 : 배치처리에 특화된 기술
    - 스프링 클라우드 : 클라우드 기술
    - 등등등
스프링 단어
- 스프링이라는 단어는 문맥에 따라 다르게 사용
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계,,
- 스프링의 핵심 컨셉
    - 좋은 객체 지향 애플리케이션을 개발 할 수 있게 도와주는 프레임워크

좋은 객체지향 프로그래밍 : 유연하고 변경이 용이한 프로그래밍
- 캡슐화
- 상속
- 추상화
- 다형성 : 클라이언트를 변경하지않고, 서버의 구현 기능을 유연하게 변경 할 수 있다.
    - 역할에 대해서만 의존을 하고, 구현에는 의존을 하지 않는다.
        - 유연해지고 변경도 편리해진다.
        - 클라이언트는 구현 대상의 내부 구조를 몰라도 되고, 변경되어도 영향을 받지 않는다.
        - 역할 : 인터페이스 추상 클래스 , 구현 : 인터페이스를 구현한 클래스나 구현 객체
    - 자바 언어에서의 다형성은 오버라이딩, 오버로딩
    - 인터페이스를 안정적으로 잘 설계하는것이 중요하다.

스프링과 객체 지향
- 다형성이 가장 중요하다.
- 스프링은 다형성을 극대화 해서 이용 하도록 도와준다.
- 제어의 역전, 의존관계 주입은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

좋은 객체지향 설계의 5가지 원칙. SOLID
- SRP : 단일 책임 원칙
    - 하나의 클래스는 하나의 책임만 가져야 한다.
    - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.
- OCP : 개방-폐쇄 원칙 ,, 스프링에서 가장 중요!
    - 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
    - 다형성을 활용해보면
        - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 구현한다
        - 구현 객체를 변경 하려면 클라이언트 코드를 변경해야 한다.
            - OCP 원칙을 지킬 수 없음
        - 문제 해결을 위해서 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- LSP : 리스코프 치환 원칙
    - 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
        - 기능적으로 보장을 해야함, 인터페이스에서 규약을 걸어주는것. (지키지 않을시 컴파일 불가)
- ISP : 인터페이스 분리 원칙
    - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
    - 인터페이스 자체가 변해도 다른 클라이언트에게 영향을 주지 않도록 독립적인 기능으로 분리를 시켜야 한다.
    - 인터페이스가 명확해지고 대체 가능성이 높아진다.
- DIP : 의존관계 역전 원칙 얘도 스프링에서 가장 중요
    - 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
        - 역할에 의존해야지 구현에 의존하면 안됨
- 다형성 만으로는 OCP,DIP를 지킬 수 없고, 뭔가 더 필요하다.
    - 스프링은 OCP,DIP를 가능하도록 DI, DI 컨테이너를 제공해준다.
- 인터페이스 도입시 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용 후 필요 할 때 리팩터링해서 인터페이스를 도입하는것도 방법이다.

프로젝트 생성
- 스프링 부트 생성
- 컴파일 인텔리제이로 실행 설정
    - Preference > Gradle > Build and runusing: gradle
    - Preference > Gradle > run tests using: gradle 
- 구현체가 하나면 관례상 구현체를 ServiceImpl 이라고 많이 씀..
- Enum 타입 비교는 ==으로 함
- 테스트 파일 만드는 단축키 : 클래스 레벨에 커서 두고 command + shift+ t
- 기존 코드에는 인터페이스와 클래스 둘 다 의존하고 있었음,
    - 인터페이스만 의존하게 설정하면 NPE 발생,, 구현체를 지정해줘야함 ,,

관심사의 분리
- 객체마다 책임을 확실히 분리해야 함,
- AppConfig 등장 : 애플리케이션 전체 동작 방식을 구성(config)하기위해 구현 객체를 생성하고, 연결하는 책임을 갖는 별도의 설정 클래스를 만든다.
    - 애플리케이션의 실제 동작에 필요한 구현 객체를 생성 함 !
    - 생성한 객체 인터페이스의 참조를 생성자를 통해 주입(연결)해준다 .
    - 설계 변경으로 Impl은 구현한 Repo 클래스를 의존하지 않음,
        - 단지 Repo 인터페이스에 의존한다.
        - 의존관계에 대한 고민은 외부에 맡기고, 실행에만 집중하면 된다…!!
        - AppConfig가 구현체들에대한 객체를 생성해줌 >> DIP 완성
    - 관심사의 분리가 되었음,, 객체를 생성하고 연결하는 역할 / 실행하는 역할
        - memberServiceImpl 입장에서는 의존 관계를 마치 외부에서 주입해주는 것 같다고 해서 DI,, 의존성 주입이라고 함.
        - AppConfig를 통해 관심사를 확실히 분리 했음, 구체 클래스를 선택해줌,,
        - Impl은 기능을 실행하는 책임만 진다.
    - AppConfig 리팩터링
        - 구현체의 중복을 제거해서 다른 구현체로 변경시 하나만 변경하면 되도록 리팩토링 처리 
        - 사용 영역의 어떤 코드도 변경 할 필요가 없음, 구성 영역은 변경시켜야함.

프로젝트내에서의 SOLID
- SRP 단일 책임 원칙을 따르며 관심사를 분리함
    - 구현 객체를 생성하고 연결하는 책임은 AppConfig 담당
    - 클라이언트 객체는 실행하는 책임만 담당
- DIP 의존관계 역전 원칙 / 추상화에 의존해야지, 구체화에 의존하면 안된다.
    - 기존 서비스는 추상화에 의존하면서도 동시에 구체화 구현 클래스에도 함께 의존했음
    - AppConfig를 통해 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입.
- OCP 개방 폐쇄의 원칙 / 확장에는 열려있고 변경에는 닫혀있어야 한다.
    - 애플리케이션을 사용영역과 구성 영역으로 나눴음
    - AppConfig가 의존관계를 클라이언트 코드에 주입(구현체 생성자를 통해)
    - 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있다.

프레임워크 vs 라이브러리
- 프레임워크는 내가 작성한 코드를 제어하고,. 대신 실행
- 라이브러리는 내가 작성한 코드를 직접 제어의 흐름을 담당

IOC , DI, 컨테이너
- IOC 제어의 역전 : 프로그램의 제어 흐름을 직접 제어하는것이 아니라 외부에서 관리하는 것
    - 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 객체를 생성하고, 연결하고, 실행했다.
    - AppConfig 등장 이후, 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 AppConfig가 가져감  프로그램의 제어 흐름을 모두 AppConfig가 생성 및 제어
- DI 의존관계 주입 
    -  정적인 클래스 의존관계
        - import 코드만 보고도 의존관계 쉽게 판단 가능 / 정적인 클래스 의존관계는 코드를 실행하지 않아도 분석이 가능
        - 정적인 클래스 의존관계만으로는 실제 어떤 객체가 올 지는 알 수가 없다.
    - 실행 시점에 결정되는 동적인 객체 인스턴스 의존관계
        - 실행시점에 외부(AppConfig)에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는것을 의존관계 주입이라고 한다.
    - 의존관계 주입을 사용하면 클라이언트 코드를 변경하지않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경 할 수 있다.
    - 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 관계를 변경 할 수 있다.
- IoC 컨테이너, DI 컨테이너, 둘이 같은 말 ,, 최근에는 DI 컨테이너라고 함 
    - AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것 

스프링으로 전환하기
- 스프링 컨테이너
    - 스프링 컨테이너는 BeanFactory와 ApplicationContext로 구분해서 이야기 하는데, BeanFactory를 직접 사용 하는 경우는 거의 없으므로, 일반적으로 ApplicationContext가 스프링 컨텍스트라고 한다.
    - 기존에는 개발자가 AppConfig를 사용해서 직접 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너로 사용
    - @Configuration이 붙은 클래스를 설정정보로 사용하고, @Bean인 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록
        - 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 함
        - 스프링 빈은 @Bean이 붙은 이름(default : 메서드 이름, name속성으로 설정 가능)을 스프링 빈 이름으로 사용한다.
            - 빈 이름은 항상 다른 이름을 부여해야함 
        - 이전에는 AppConfig를 직접 조회했지만, 이제는 스프링 컨테이너를 통해 필요한 스프링 빈을 찾아야 함
        - applicationContext.getBean(이름,타입)으로 스프링 빈을 찾을 수 있다.
        - 스프링 컨테이너에서 스프링 빈을 찾아서 사용해야한다.
        - 빈들간 동적인 의존관계를 설정해준다. 
        - 스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나누어져있다, 그런데 자바코드로 스프링 빈을 등록하면 생성자 호출하며 의존관계 주입도 한 번에 처리한다.
    - 스프링 컨테이너의 장점 : ??? 어마어마 함,,
    - 컨테이너 생성 과정 
        - 스프링 컨테이너는 XML 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스를 만들 수 있다.
        - ApplicationContext : 스프링 컨테이너, 인터페이스
        - AnnotationConfigApplicationContext : 애노테이션 기반 구현체
    - 스프링 빈 조회 - getBean을 하면 되는데,, 잘 쓸일이 없음,,
        - 컨테이너에 등록된 모든 빈 조회
            - ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회
            - ac.getBean(빈이름,타입) or ac.getBean(타입) : 빈 이름 혹은 타입 으로 빈 객체를 조회한다.
                - 없는 빈 조회시 NoSuchBeanException 발생
        - 동일한 타입이 둘 이상인 경우 : 
            - NoUniqueBeanDefinitionException 발생
            - 해결 방법 : 빈의 이름을 설정해준다.
            - ac.getBeansOfType() 사용 시 해당 타입의 모든 빈 조회 가능
        - 상속관계
            - 부모타입으로 조회하면 자식 타입도 함께 조회한다.
    - BeanFactory와 ApplicationContext
        - ApplicationContext는 BeanFactory를 상속받은 인터페이스.
        - BeanFactory는 스프링 컨테이너의 최상위 인터페이스
            - 스프링 빈을 관리하고 조회하는 역할을 담당한다.
            - getBean()등을 제공
        - ApplicationContext : BeanFactory의 모든 기능을 상속받아서 제공,
            - 메세지소스를 활용한 국제화 기능
                - 웹사이트 내 국제화 파일등을 분리해놓음..
            - 환경 변수
                - 로컬, 개발(테스트서버), 운영등을 구분해서 처리
            - 애플리케이션 이벤트
                - 이벤트를 발행하고, 구독하는 모델을 편리하게 지원
            - 편리한 리소스 조회
                - 파일, 클래스패스, 외부등에서 리소스를 추상화시켜 편리하게 조회하는 기능
        - 다양한 설정 형식 지원,, : 요즘엔 거의 자바파일, 예전엔 XML,, Groovy도 지원
            - 자바코드
                - new AnnotationConfigApplicationContext(AppConfig.class)
            - XML
                - 요즘엔 거의 안쓰지만, 아직 많은 레거시 프로젝트들이 XML로 되어있음,,
        - 스프링 빈 설정 메타 정보 - BeanDefinition
            - BeanDefinition으로 추상화시켜서 @Bean, <bean>당 하나씩 메타 정보를 생성함,,
                - 스프링 컨테이너는 이 메타 정보를 기반으로 스프링 빈을 생성한다!
                - AnnotateBeanDefinitionReader를 통해서 @Configuration을 읽어 @Bean에 해당하는 빈의 메타정보를 생성한다.
                - 직접 생성해서 스프링 컨테이너에 등록 할 수 있지만 직접 정의할 일은 거의 없음
                - 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용한다 정도만 이해

* test
    * Assertion
        * junit
            * assertThrow
        * assertj
            * assertThat
                * isEqualTo : 값을 비교하는 메서드이지만, 객체를 비교하는경우 참조를 비교하게 된다.
                * isSameAs : 참조가 같은지 비교한다.

싱글톤 컨테이너
- 스프링은 기업용 온라인 서비스 기술 지원을 위해 탄생,
    - 대부분은 웹 어플리케이션이고, 웹이 아닌 개발도 얼마든지 개발 가능,, 
    - 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
        - 싱글톤이 아닌 요청은 객체를 계속 생성을 한다. >> 트래픽 초당 100이면 초당 객체가 100개 이상으로 생성되고 소멸됨,,
        - 해결 방안은 해당 객체가 딱 1개만 생성되고 공유하도록,, >> 싱글톤 패턴
- 싱글톤 패턴 : 클래스의 인스턴스가 딱 1개만 생성되는것을 보장하는 디자인 패턴 
    - 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함
        - private 생성자를 사용, 외부에서 생성하지 못하도록 막아야 함 
        - 구현 방법은 여러가지가 있음
    - 고객의 요청이 올 때 마다 객체를 생성하는것이 아닌, 이미 만들어진 객체를 사용함,,
    - 단점
        - 구현 코드가 많이 들어감
        - 의존관계상 클라이언트가 구체 클래스에 의존 -> DIP 위반, OCP 원칙 위반 할 가능성이 높음
        - 유연하게 테스트하기 어려움
        - private 생성자를 사용하기 때문에 자식 클래스를 만들기 어려움
        - 안티패턴으로 불리기도 한다.

스프링의 싱글톤 컨테이너 : 싱글톤의 문제점을 다 해결하면서 인스턴스를 싱글톤으로 관리한다 !!
- 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
- 지저분한 코드가 들어가지 않아도 되고, DIP,OCP, 테스트의 유연성, private 생성자로부터 자유롭게 싱글톤을 사용 할 수 있다.
- 기본적으로는 싱글톤 사용하지만, 요청 할 떄마다 새로운 객체를 생성해서 반환하는 기능도 제공을 한다. (99.9%는 싱글톤사용)

싱글톤 방식의 주의점
- 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에, 상태를 유지하게 설계하면 안된다.
    - 항상 ! 무상태(stateless) 설계해야한다.
        - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
        - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
        - 가급적 읽기만 가능해야 한다.
        - 필드 대신 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.
    - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생 할 수 있다.

@Configuration과 싱글톤
- Configuration이 붙은 클래스도 빈에 등록이 된다. 근데
    - CGLIB라는 바이트코드 조작 라이브러리를  사용해서 AppConfig 클래스를 상속받은 다른 클래스를 만들고, 그 클래스를 스프링 빈으로 등록 한 것
        - @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 없으면 만들었던 로직을 호출해주는 동적 코드가 생성됨.
        - AppConfig를 상속하고있기 빈 조회시 해당 빈이 호출 된 것
- @Configuration은 싱글톤을 위해서 존재함
    - @Configuration을 붙이지않으면 마찬가지로 빈이 등록이 되지만, 싱글톤이 보장되지않게 빈이 등록이 됨, (객체가 호출 할 때마다 다중 생성 됨)
- 스프링 설정 정보에는 항상 @Configuration을 한다.

컴포넌트 스캔과 의존관계 자동 주입
- 빈이 수백개가 넘어가면서 누락 할 수 있고, 굉장히 번거로워짐.. 따라서 설정정보 없이 자동으로 스프링 빈을 등록하는 컴포넌트 스캔을 지원
- @Autowired : 의존관계를 자동 주입해주는 애노테이션
    - 생성자에 붙여주면 해당 생성자의 타입에 맞는 빈을 찾아서 의존관계 주입을 자동으로 연결해서 주입한다.
        - 기본 조회 전략 : 스프링 빈 저장소에서 해당 빈을 타입에 맞추어 찾고, 등록한다.
        - 생성자에 파라미터가 많아도 다 찾아서 자동으로 주입을 해준다.

- @ComponentScan : @Component 애노테이션이 붙은 모든것들을 스프링 빈으로 자동 등록
    - 순서
        - 1. 컴포넌트 스캔에 해당하는 AppicationContext 실행시, @Component 가 붙은 모든 클래스를 스프링 컨테이너에 빈을 등록한다.
        - 2. @Autowired을 이용해서 타입을 기준으로 의존관계를 주입한다.
    - excludeFilters라는 속성을 지정해서 읽지 않을 어노테이션을 지정 할 수 있음
    - @Component를 사용 할 구현체에 붙여준다.
    - 스프링 빈 기본 이름은 클래스명을 사용하되, 맨 앞글자만 소문자를 사용한다.
        - 직접 지정하고싶으면 @Conponent(“memberService2”) 이런식으로 지정 가능,, 왠만하면 Default 사용 권장 
